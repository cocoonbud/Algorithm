![image.png](https://pic.leetcode-cn.com/1630948492-MZuqco-image.png)

#### 读题

1. 平衡字符串 s

2. 需要分割成尽可能多的平衡字符串。

   啥叫平衡字符串？'L' 和 'R' 数量相同。

要求：分割平衡字符串 s，返回子平衡字符串的最大数量。

#### 解题思路

看着道题莫名想到玩消消乐，但是题目与消消乐规则不同。

我们选择一个颜色的方块 'R' 做个基准，然后遇到 'R'，就记录++，遇到 'L'，就记录--。等记录为0的时候。这不就相当于你一小段消除没了么。这不就是相当于本题的获得了一个子平衡字符串。当然你以 'L' 为基准也 ok。

然后继续循环完。done。

题目例子 RL RRLL RL RL

对应就是 +-  ++--  +-  +-



来到代码层面， 可以在遍历平衡字符串 s 时用变量 count 维护 'L' 和 'R' 字符的数量差，当 count = 0 时就说明分割到了一个子平衡字符串，结果 res++。

就是这么简单。

这道题也是旧题再刷，只不过这次的代码更精炼。所以熟能生巧啊

看到大家一水的说是贪心算法，我怎么感觉只是个简单模拟题。

贪心的思想：由局部最优到全局最优的思想没看出来有啥体现？懂的大佬烦请提点下？

**### 代码**

```c++
class Solution {
public:
    int balancedStringSplit(string s) {
        int res = 0, count = 0;
        for (char c : s) {
            c == 'L' ? count++ : count--;
            if (count == 0) res++;
        }
        return res;
    }
};
```

